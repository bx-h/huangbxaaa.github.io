'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/en/posts/javanote_6/','title':"JavaNote_6",'content':"摘要：优化for循环；IO流；\n其他语法补充 #  foreach #  1 2 3  for(int data : arr) { System.out.println(data); }   集合遍历的方式（总结：针对有下标的集合，指list）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class ForEachTest { public static void main(String[] args) { List\u0026lt;String\u0026gt; mylist = new ArrayList\u0026lt;\u0026gt;(); mylist.add(\u0026#34;hello\u0026#34;); mylist.add(\u0026#34;world\u0026#34;); mylist.add(\u0026#34;kitty\u0026#34;); // 使用迭代器  Iterator\u0026lt;String\u0026gt; it = mylist.iterator(); while (it.hasNext()) { String s = it.next(); System.out.println(s); } // 使用下标  for (int i = 0; i \u0026lt; mylist.size(); ++i) { System.out.println(mylist.get(i)); } // 使用foreach  for (String s : mylist) { System.out.println(s); } } }   IO流 #  java.io\nIO流：硬盘\u0026mdash;\u0026ndash;内存\n流的分类 #  按流的方向：\n 输入流：硬盘\u0026ndash;\u0026gt;内存 输出流：内存\u0026ndash;\u0026gt;硬盘  按数据：\n  字节流：一次读取一个byte（8 比特）。万能流，可以读取任何类型的数据。\n  字符流：一次读取一个字符。只能读取普通文本文件。（txt）\n   在Windows系统中：英文一个字符一个字节，中文一个字符两个字节\n在Java中，char占两个字节\n 四大家族（以下都为家族大家长，为抽象类）：\n   名称 接口     java.io.InputStream 字节输入流 Closeable   java.io.OutputStream 字节输出流 Closeable, Flushable   java.io.Reader 字符输入流 Closeable   java.io.Writer 字符输出流 Closeable, Flushable    在java中，类名凡是以\u0026rsquo;Stream\u0026rsquo;结尾的，都是字节流家族；以‘Reader/Writer’结尾的，都是字符流家族。\n好习惯：\n 用完流要close() 用完输出流要flush()，清空管道  要掌握的 #     名称      文件专属    java.io.FileInputStream    java.io.FileOutputStream    java.io.FileReader    java.io.FileWriter        转换流（字节流\u0026ndash;\u0026gt;字符流）    java.io.InputStreamReader    java.io.OutputStreamWriter        缓冲流    java.io.BufferedReader    java.io.BufferedWriter    java.io.BufferedInputStream    java.io.BufferedOutputStream        数据流    java.io.DataInputStream    java.io.DataOutputStream        对象流    java.io.ObjectInputStream    java.io.ObjectOutputStream        标准输出流    java.io.PrintWriter    java.io.PrintStream     FileInputStream #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public class Test { public static void main(String[] args) { FileInputStream fis = null; try { // 创建文件字节输入流对象  fis = new FileInputStream(\u0026#34;\u0026lt;filepath\u0026gt;\u0026#34;); // 开始读  // read()返回读取到的ascii码，每调一次文件帧往后移动一个字节，文件末尾返回-1  int readData = fis.read(); // 循环来读  int readData2 = 0; while((readData2 = fis.read()) != -1) { System.out.println(readData2); } // 一次读一个字节效率低，内存硬盘交互次数太多  // 一次读取多个字节。采用byte数组，一次最多读取数组长度的字节，并从数组头开始覆盖。  // 返回每次调用读到的字节数量。假如一个字节都没读到，就返回-1  // 假设文件里为\u0026#34;abcdef\u0026#34;  byte[] bytes = new byte[4]; int count = fis.read(bytes); // 4  System.out.println(new String(bytes)); // abcd  count = fis.read(bytes); // 2  System.out.println(new String(bytes)); // efcd  // 应该根据读取到的字节count来输出：  System.out.println(new String(bytes, 0, count)); // ef  // 循环的形式  int readcount = 0; while((readcount = fis.read(bytes)) != -1) { System.out.print(new String(bytes, 0, readcount)); } } catch (IOException e) { e.printStackTrace();\t} finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } }   综上，恰当的读取文件代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public class ReadFile { public static void main(String[] args) { FileInputStream fis = null; try { fis = new FileInputStream(\u0026#34;\u0026lt;filepath\u0026gt;\u0026#34;); byte[] bytes = new byte[4]; int readcount = 0; while((readcount = fis.read(bytes)) != -1) { System.out.print(new String(bytes, 0, readcount)); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } }    IDEA的默认当前路径为工程的根\n 其他的方法\nint available() ：返回还没读到的字节数量\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Test { public static void main(String[] args) { FileInputStream fis = null; try { // 不用循环，直接读到文件所有内容  // 不适合大文件  fis = new FileInputStream(\u0026#34;\u0026lt;filepath\u0026gt;\u0026#34;); byte[] bytes = new byte[fis.available()]; int readCount = fis.read(bytes); } ... } }   long skip(long n)：跳过几个字节不读。\n"});index.add({'id':1,'href':'/en/posts/','title':"Posts",'content':""});index.add({'id':2,'href':'/en/posts/javanote_5/','title':"JavaNote_5",'content':"摘要：Map；泛型；\nMap #   Map集合和Collection集合没有关系。Map以键值对的方式存储元素。key和value都是存储java对象的内存地址（引用），存储元素特点相同。 HashMap底层是哈希表，非线程安全；Hashtable底层也是哈希表，线程安全，效率较低，一般不用。 SortedMap中会自动按照key自己大小排序。 TreeMap底层是一个二叉树。Key可以自己按照大小排序。 Properties是线程安全的，另外Properties存储的key和value都是String类型。  官方文档一些方法的解释 #  Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet()\n将Map集合转为Set集合。\ne.g.\nMap集合\n   key value     1 zhangsan   2 lisi    执行：Set set = map1.entrySet();\nset集合\n   element , 类型为: Map.Entry\u0026lt;K, V\u0026gt;, 是Map中的一个静态内部类     1=zhangsan   2=lisi    静态内部类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class Myclass { public static class Innerclass { public static void m1() { System.out.println(\u0026#34;I am static function m1 in Innerclass\u0026#34;); } public void m2() { System.out.println(\u0026#34;我是Innerclass中的实例方法\u0026#34;); } } public static void main(String[] args) { Myclass.Innerclass.m1(); Myclass.Innerclass mclass = new Myclass.Innerclass(); mclass.m2(); } }   遍历 #  方法1：将key转为set，遍历获得value\n方法2：将整个map转为set。元素变为：Map.Entry\u0026lt;\u0026gt;。效率更高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class MapTest{ public static void main(String[] args) { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;zhangsan\u0026#34;); map.put(2, \u0026#34;lisi\u0026#34;); map.put(3, \u0026#34;wangwu\u0026#34;); // 方式1：获取所有的key，遍历key，来遍历value  Set\u0026lt;Integer\u0026gt; keys = map.keySet(); // 遍历keys：迭代器或者foreach  Iterator\u0026lt;Integer\u0026gt; it = keys.iterator(); while(it.hasNext()) { Integer key = it.next(); String value = map.get(key); System.out.println(key + \u0026#34;=\u0026#34; + value); } /* for(Integer key : keys) { String value = map.get(key); System.out.println(key + \u0026#34;=\u0026#34; + value); } */ // 方式2：把map集合整个转换为set集合。效率更高。  Set\u0026lt;Map.Entry\u0026lt;Integer, String\u0026gt; \u0026gt; m_set = map.entrySet(); Iterator\u0026lt;Map.Entry\u0026lt;Integer, String\u0026gt; \u0026gt; it2 = m_set.iterator(); while(it2.hasNext()) { Map.Entry\u0026lt;Integer, String\u0026gt; node = it2.next(); Integer key = node.getKey(); String value = node.getValue(); System.out.println(key + \u0026#34;=\u0026#34; + value); } } }   HashMap #    底层为散列表、哈希表的数据结构\n  什么是哈希表？\n 数组和单向链表的结合体 结合了数组查询效率高与链表增删效率高的优点 类似珠珠门帘    无序不可重复\n  底层源代码：\n1 2 3 4 5 6 7 8 9 10 11  public class HashMap { // 底层为一维数组  Node\u0026lt;K, V\u0026gt;[] table; // 静态内部类HashMap.Node  static class Node\u0026lt;K, V\u0026gt; { final int hash; // key执行hashCode()的结果，hash通过哈希算法可以转为下标。  final K key; V value; Node\u0026lt;K, V\u0026gt; next; } }     需要重写equals()和hashCode()方法。\n  要设定恰当的hashCode方法。假如hashCode方法返回固定值，则变成链表。假如每个key都返回不同的hash，则变为数组。因此，要使hashCode方法返回的值散列分布均匀。\n  HashMap集合的默认初始化容量为16，默认加载因子为0.75。即容量达到75%时，数组开始扩容，扩容后是原容量的2倍。初始容量推荐为2的倍数。\n  put方法\n 先将key，value封装到Node对象中 底层调用key的hashCode()方法得出hash值 通过哈希算法，将hash值转为数组下标 如果下标位置没有任何元素，直接把Node添加到该位置 如果下标位置已经有元素，则将key与链表上的key一一使用equals()进行对比。如果全部返回false，则将Node添加到链尾；否则，使用Node的value值替换掉链表上对应Node的value值。  get方法\n 先调用key的hashCode()方法获得哈希值，通过哈希算法转为数组下标 如果下标位置没有元素，返回null 否则，拿着key与链表上的key一一比较，返回链表上对应key的value  为什么哈希表的增删和查询的效率高？\n 增删在链表上高 查询只需要在部分数据上查询  更新：JDK8之后，当某数组位置的链表长度大于8时，链表变为红黑树。当红黑树的节点数量小于6时，重新变为单向链表。\nhashMap的key允许为空，但只能存在一个。即：null值作为key和普通值一样。\n为什么要同时重写hashCode和equals方法？\n 如果两个对象相等，则 hashcode一定也是相同的。两个对象有相同的hashcode值，它们不一定是相等的。（哈希碰撞）。 两个对象相等,对两个对象分别调用 equals 方法都返回 true。因此，对于两个equals的对象，hashCode也必须相同。 两个方法需要同时重写。   hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n hashCode方法与equals方法的重写 #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  public class MapTest { public static void main(String[] args) { Student s1 = new Student(\u0026#34;zhangsan\u0026#34;); Student s2 = new Student(\u0026#34;zhangsan\u0026#34;); System.out.println(s1.equals(s2)); // 重写equals方法前为false，重写后为true  // 假如不重写hashCode方法，s1和s2的hashCode不同。（默认返回地址）  System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); Set\u0026lt;Student\u0026gt; students = new HashSet\u0026lt;\u0026gt;(); students.add(s1); students.add(s2); System.out.println(students.size()); /* 只重写equals没重写hashCode：由于HashSet会先调用hashCode方法确定哈希表上数组下标，因此s1和s2会被放入两个位置，输出2； 因此，若重写equals，equals返回true，hashCode方法必须返回相同的值。 */ } } class Student { private String name; public Student() {} public Student(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } // hashCode  /* @Override public int hashCode() { return Objects.hash(name); // 此处将对同样name的对象返回一样的哈希值 } */ // equals  @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return Objects.equals(name, student.name); } }   HashTable #  key和value都不能为null\n方法都带有synchronized，效率低。\nProperties #  一个Map集合，继承HashTable，Properties的key和value都是String类型。\nProperties被称为属性类对象。是线程安全的。\nsetProperty(String key, String value)\ngetProperty(String key)\nTreeMap #  TreeSet底层实际为TreeMap。放到TreeSet中的元素，等同于放到TreeMap的key部分。可以自动排序。\nTreeMap集合底层是一个二叉树。\n 泛型 #  指定集合中的元素类型。\n1 2 3 4 5 6  List\u0026lt;E\u0026gt; mylist = new ArrayList\u0026lt;E\u0026gt;(); Iterator\u0026lt;E\u0026gt; it = mylist.iterator(); while(it.hasNext()) { E ele = it.next(); // 获得的是E，不再是Object。 }   泛型的好处？\n 集合中存储的元素类型统一 从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”  泛型的缺点？\n导致集合中存储的元素缺乏多样性。\nJDK8之后，出现自动类型推断，称为钻石表达式\n1  List\u0026lt;E\u0026gt; mylist = new ArrayList\u0026lt;\u0026gt;(); // 可以省略后面的类型。   自定义泛型\n1 2 3 4 5 6 7 8 9 10  public class GenericTest\u0026lt;标识符随便写\u0026gt; { public void doSome(标识符随便写 o) { // 标志符一般为E或者T \tSystem.out.println(o); } public static void main(String[] args) { GenericTest\u0026lt;String\u0026gt; gt = new GenericTest\u0026lt;\u0026gt;(); gt.doSome(此处只能传String) } }   "});index.add({'id':3,'href':'/en/posts/javanote_4/','title':"JavaNote_4",'content':"摘要：Date；数字类；枚举；异常与错误；集合\nDate [Java.util] #  构造方法\n1 2 3  import java.util; Date nowTime = new Date(); //获取系统当前时间   SimpleDateFormat [java.text] #  自定义格式的日期，可以将Date格式化为String\n1 2 3  SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss SSS\u0026#34;); String nowTimeStr = sdf.format(nowTime); //使用上文的nowTime    将String转为Date\n1 2 3 4  String time = \u0026#34;2008-08-08 08:08:08 888\u0026#34;; SimpleDateFormat sdf2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss SSS\u0026#34;); //要和字符串要表达的格式一样 Date dateTime = sdf2.parse(time); System.out.println(dateTime);   1970.01.01到系统目前时间的总毫秒数。可以用于统计程序运行时间。\n1 2 3 4 5 6  long nowTimeMillis = System.currentTimeMillis(); //统计运行时间 long begin = System.currentTimeMillis(); doSomething(); long end = System.currentTimeMillis(); System.out.println(\u0026#34;耗费时长\u0026#34; + (end - begin) + \u0026#34;毫秒\u0026#34;);   总结\n数字类 #  数字格式化：DecimalFormat [java.text] #  1 2 3 4 5 6 7 8 9 10 11  /* # 代表任意数字 , 代表千分位 . 代表小数点 0 不够补0 */ DecimalFormat df = new DecimalFormat(\u0026#34;###,###.##\u0026#34;); String s = df.format(1234.56); // 输出：\u0026#34;1,234.56\u0026#34;  DecimalFormat df2 = new DecimalFormat(\u0026#34;###,###.0000\u0026#34;); //保留4位小数，不够补0 String s1 = df.format(1234.56); //输出：\u0026#34;1,234.5600\u0026#34;   高精度数据BigDecimal #  BigDecimal 属于大数据，精度极高。不属于基本数据类型，属于引用数据类型。这是SUN提供的一个类，专门用于财务软件中。\njava.math.BigDecimal\n1 2 3  BigDecimal v1 = new BigDecimal(100); BigDecimal v2 = new BigDecimal(200); BigDecimal v3 = v1.add(v2); // 不能直接用+号，因为不是基本类型。减乘除同理。   随机数 #  1 2 3 4 5 6 7  Random random = new Random(); // 随机产生一个int类型取值范围内的数字 int num = random.nextInt(); // 产生[0, 100]之间的随机int数 int num2 = random.nextInt(101);    枚举 #  一枚一枚可以列举出来的。Boolean就是两种情况的枚举。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 定义 enum Result { SUCCESS， FAIL } // 使用 Result.SUCCESS; Result.FAIL; // 例子 public static Result devide() { if (...) { return Result.SUCCESS; } else { return Result.FAIL; } }    异常 #  异常在java中以类的形式存在，每一个异常类都可以创建异常对象。\n发生异常时，JVM会new异常对象，并抛出，打印信息到控制台。\n编译时异常 #   要求程序员在编写程序阶段必须处理完毕。用throw或者try catch 一般是在编写程序时就预料到可能会发生异常，如读写文件时文件不存在  运行时异常 #  也叫“非受控异常”，“未受检异常”。在编写程序时无法被编译器检查出来，也可以不进行处理。\n错误 #  error发生时，java程序只能够终止，JVM退出。\n对异常的处理 #  假如一个方法带着throw ...，那么调用它时，会接受到异常。要对它进行处理。要么自己捕捉，要么继续上报。\n发生异常时的两种处理方式：\n 在方法声明的位置上使用throw，来完成异常的继续上抛，抛给上一级。并且抛出的异常要么等于接收到的异常，要么是接收到的异常的父类。（上报） 使用try...catch进行捕捉，在本级处理（捕捉）  只要异常没有捕捉，采用上报throw的方式，throw后面的代码不会执行。\n另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。\njdk8新特性：允许catch多种异常\n1 2 3 4 5  try { } catch(FileNotFoundException | ArithmeticException | NullPointerException e) { }   也可以直接写这些所有异常的父类Exception\n异常的方法 #  获取异常简单的描述信息：String msg = exception.getMessage();\n打印异常追踪的堆栈信息：exception.printStackTrace(); 异步方式输出。\n如何看异常追踪堆栈信息？\n从上往下看，忽略掉SUN公司的代码定位处。查看第一个出现的自己代码错误的位置，越往下越往父函数（调用者）跳。\nfinally #  finally中的代码一定会执行。\ntry可以不跟catch，只跟finally\n如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  /* 执行顺序：1 -\u0026gt; 3 -\u0026gt; 2 finally一定会执行，return最后执行。 */ try { System.out.println(\u0026#34;try....\u0026#34;); // 1 \treturn; // 2 } finally { System.out.println(\u0026#34;finally...\u0026#34;); //3 } System.out.println(\u0026#34;Hello\u0026#34;); // 这句语句没法执行到。    但是，假如采用exit退出jvm，则finally无法执行\n1 2 3 4 5 6 7 8  try { System.out.println(\u0026#34;try....\u0026#34;); // 1 \tSystem.exit(0); // 2 } finally { System.out.println(\u0026#34;finally...\u0026#34;); // 这句语句没法执行到 } System.out.println(\u0026#34;Hello\u0026#34;); // 这句语句没法执行到。    面试题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class ExceptionTest { public static void main(String[] args) { int result = m(); System.out.println(result); // 100  } public static int m() { int i = 100; try { return i; // 执行到这里时，暂时把i存储起来。  } finally { i++; // ++i; 效果相同  } } }   反编译：（反编译工具：DJ Java Decompiler）\n可见，把i的值先暂时存储到j中。\n面试题: final, finally, finalize的区别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class ExceptionTest { public static void main(String[] args) { // final表示关键字，表示修饰的变量不可变。 \tfinal int = 100; // finally是一个关键字，与try连用，用在异常处理机制中，finally中的方法一定会执行 \ttry { } finally { System.out.println(\u0026#34;finally....\u0026#34;); } // finalize() 是Object类中的一个方法，作为方法名出现。 \t// 所以finalize是标识符。已过时。  // 它是被JVM的垃圾回收器进行调用的 \t} }   自定义异常 #  SUN公司提供的异常肯定是不够用的，需要我们自定义与实际业务挂钩的异常类。\n如何定义：\n第一步，编写一个类继承Exception（定义为编译时异常）或者Runtime Exception（定义为运行时异常）。假如异常发生概率较高，则定义为编译时异常，强制程序员提前处理比较好。假如发生概率低，则定义为运行时异常。\n第二步，提供两个构造方法，一个无参数的，一个带有String参数的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class ExceptionTest{ public static void main(String[] args) { MyException e = new MyException(\u0026#34;其实你没有什么错误\u0026#34;); e.printStackTrace(); } } class MyException extends Exception { public MyException(){ super(); } public MyException(String s) { super(s); } }   修改之前的数组模拟栈程序：\n注意，代码体中是throw，函数声明上是throws.\n异常进行上抛，要在方法声明上写好throws，不能自己抛自己try catch。抛到main函数中进行捕捉处理。\n异常方法的重写 #  子类中重写的方法抛出的异常不能比父类中的异常更宽泛，更多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Animal { public void doSome() {} public void doOther() throws Exception { } } class Cat extends Animal { public void doSome() throws Exception {} // 编译错误。  /* public void doOther() {} // 正常 public void doOther() throws Exception {} // 正常 public void doOther() throws NullPointerException {} // 正常 */ }   编程习惯经验分享\n![ScreenClip [1]](/picture/JavaNote_4-ScreenClip [1].png)\n一个很好的案例：（武器项目，涉及接口，多态，异常处理，数组）\nhttps://www.bilibili.com/video/BV1mE411x7Wt?p=182\njava进阶视频第182集\n集合 #  概念 #  集合不能直接存储基本数据类型（对于基本数据类型，会执行自动装箱转为包装类型），且集合也不能直接存储Java对象。集合当中存储的都是Java对象的内存地址。（或者说集合中存储的引用）。\n集合在Java中本身也属于一个对象。因此集合也可以存储集合。（一个塑料袋装苹果，一个塑料袋装梨子，再用一个大袋子装两袋水果。）\n每一个不同的集合，底层会对应不同的数据结构。如：数组，二叉树，链表，哈希表。。（菜篮子，塑料袋，布袋子）\n集合在JDK哪个包下？java.util.*\n体系结构 #  在java中集合分为两大类：\n一类是单个方式存储元素，这一类集合的父接口为：java.util.Collection;\n一类是以键值对的方式存储元素，这一类集合的父接口为：java.util.Map;\nCollection #  Vector：是线程安全的，效率较低，一般不用。\nArrayList：是非线程安全的，但是效率高。\nLinkedList：底层是双向链表\nHashSet：底层是HashMap，放到HashSet集合中的元素等同于放到HashMap集合Key部分了。\nTreeSet：底层是TreeMap，放到TreeSet集合中的元素等同于放到TreeMap集合Key部分了。\n这些子类的构造方法都能够传Collection类型的数据，因此所有Collection的子类都能够相互转换。\nCollection #  Collection能够存储什么元素？\n假如没有使用泛型，Collection中能够装任意Object的子类。\n一些方法：\n   方法 含义     boolean add(Object e) 添加元素   int size() 获取集合中元素个数   void clear() 清空集合   boolean contains(Object e) 判断集合中是否存在某个元素   boolean remove(Object e) 删除集合中某个元素   boolean isEmpty() 判断集合是否为空   Object[] toArray() 将集合转为数组    迭代 #  以下迭代方式，适用于除了Map之外的所有的Collection的子类。\n1 2 3 4 5 6 7 8 9 10  Collection c = new HashSet(); // 第一步：获取集合对象的迭代器Iterator，指向首元素的前一位 Iterator it = c.iterator(); // 第二步：遍历 // boolean hasNext() 是否还有元素可以迭代 // Object next() 返回下一元素，取出来统一为Object类型 while(it.hasNext()) { Object obj = it.next(); System.out.println(obj); }   迭代器\n当集合的结构发生改变（增加，删除元素）时，迭代器必须重新获取；\n在迭代过程中，不能改变集合的结构（增加，删除元素），\n否则会出现java.util.ConcurrentModificationException异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import java.util.Collection; import java.util.ArrayList; import java.util.Iterator; public class CollectionTest { public static void main(String[] args) { Collection c = new ArrayList(); c.add(1); c.add(2); c.add(\u0026#34;abe\u0026#34;); Iterator it = c.iterator(); while(it.hasNext()) { Object o = it.next(); c.remove(o); // 集合结构改变，程序报错。  /* it.remove(); // 正确，不会报错。直接删除迭代器指向的元素。 */ } } }   改进方法，使用迭代器的remove方法。\n解释：调用iterator()获取迭代器时，相当于给集合拍一个快照。假如集合发生改变，那么快照将不能生效。\nContains方法 #  底层调用了equals方法进行比对，确定是否包含某个元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class CollectionTest { public static void main(String[] args) { Collection c = new ArrayList(); String s1 = new String(\u0026#34;abc\u0026#34;); c.add(s1); String s2 = new String(\u0026#34;def\u0026#34;); c.add(s2); System.out.println(\u0026#34;元素的个数是：\u0026#34; + c.size()); // 2  String x = new String(\u0026#34;abc\u0026#34;); System.out.println(c.contains(x)); // true or false?? --\u0026gt; true  // 原因：  // contains源码进行比较时,调用了equals方法。  // String重写的equals方法进行的是字符串内容的比较,而不是对象引用地址的比较。  } }   例子2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class CollectionTest2 { public static void main(String[] args) { Collection c = new ArrayList(); User u1 = new User(\u0026#34;Jack\u0026#34;); c.add(u1); User u2 = new User(\u0026#34;Jack\u0026#34;); System.out.println(c.contains(u2)); // User若没有重写equals方法，返回false；User若重写了equals方法，可以返回true  } } class User { private String name; public User(){} public User(String name) { this.name = name; } public boolean equals(Object o) { if (o == null || !(o instanceof User)) return false; if (o == this) return true; User u = (User)o; return u.name.equals(this.name); } }   结论：\n放在集合中的元素，必须重写equals方法\nList #  Collection的子类，具备Collection中没有的方法。\nObject get(index) : 根据下标获取元素。\n1 2 3 4 5  for (int i = 0; i \u0026lt; myList.size(); ++i) { Object obj = myList.get(i); System.out.println(obj); // 不需要使用迭代器，通过下标就能够访问元素 }   ArrayIist #  性质：\n 集合初始化容量为10 （JDK8以上：底层先创建了一个长度为0的空数组，当添加第一个元素时，初始化容量10） 集合底层是Object类型的数组Object[] 扩容：原容量的1.5倍。由于ArrayList底层是数组，数组的扩容效率较低，因此尽量减少扩容次数，尽量在初始化时就分配足够大的容量。 优点：检索效率高。缺点：随机增删元素效率低。无法存储大数据量（难以找到一块大的连续空进） 用的最多  位运算符：\n\u0026lt;\u0026lt;左移：乘2的n次方\n\u0026gt;\u0026gt;右移：除以2的n次方\n构造方法\n1 2 3 4 5 6 7 8  List myList1 = new ArrayList(); // 初始化容量 List myList2 = new ArrayList(100); // 可以传入一个Collection对象作为初始化 Collection c = new HashSet(); List myList3 = new ArrayList(c);   Linkedlist #  双向链表，易增删，难查询。\n但可以给链表设置下标。（虽然没什么用）\n不管是LinkedList还是ArrayList，写代码时都不需要关系具体是哪个集合。由于他们都是属于List接口，调用的方法也都是接口中的方法。\n1 2 3 4 5  List list2 = new ArrayList(); // List list2 = new LinkedList(); // 这里无论用哪种list，下面的代码都不需要改动。 list2.add(\u0026#34;123\u0026#34;); list2.add(\u0026#34;456\u0026#34;);   Vector #  用的很少。\n底层是数组，初始化容量是10。\n怎么扩容的？原容量的2倍 。\nArrayList增长是原容量的1.5倍。\nVector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的，效率较低，用的比较少。\n怎么将一个线程不安全的ArrayList集合转化为线程安全的呢？\n使用集合工具类：java.util.Collections;\njava.util.Collection是接口\n1 2 3 4 5  List myList = new ArrayList(); Collections.synchronizedList(myList); // 转为线程安全 myList.add(\u0026#34;111\u0026#34;);   Set #  无序不可重复。这里的无序指的是没有下标，存储顺序与取出顺序不同。\n但SortedSet可以排序\nset底层是map的key\nTreeSet #  可以自动进行存入元素的排序。\n方式1：\n对于自定义类，必须实现好java.lang.Comparable接口，实现里面的compareTo()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Customer implements Comparable\u0026lt;Customer\u0026gt; { int age; String name; public Customer() { } public Customer(int age, String name) { this.age = age; this.name = name; } @Override public int compareTo(Customer o) { // 自定义比较规则：按年龄排序，若年龄相同，按名字排序  // \u0026lt; 返回负数，= 返回0，\u0026gt; 返回正数  if (this.age == o.age) { return this.name.compareTo(o.name); // 调用String的compareTo方法进行字符串字典序排序  } else { return this.age - o.age; } } }   遍历时以中序遍历顺序（左根右）\n方式2：比较器的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public class WuGui { int age; public WuGui(int age) { this.age = age; } public static void main(String[] args) { TreeSet\u0026lt;WuGui\u0026gt; wuguis = new TreeSet\u0026lt;\u0026gt;(new WuGuiComparator()); // 传入比较器对象  } } class WuGuiComparator implements Comparator\u0026lt;WuGui\u0026gt; { // 定义乌龟类的比较器  @Override public int compare (WuGui o1, WuGui o2) { return o1.age - o2.age; } } // 优化：匿名内部类方式 /* ... public static void main(String[] args) { TreeSet\u0026lt;WuGui\u0026gt; wuguis = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;WuGui\u0026gt;(){ public int compare(WuGui o1, WuGui o2) { return o1.age - o2.age; } }) } ... */   若有多个比较规则，或者比较规则多变，可以使用方式2Comparator比较好\n若有单个比较规则，则使用方式1Comparable\n集合工具类 #  java.util.Collections\n1 2 3 4 5 6 7 8 9  List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 变成线程安全的 Collections.synchronizedList(list); // 排序(需要实现Comparable接口) list.add(\u0026#34;abf\u0026#34;); list.add(\u0026#34;abx\u0026#34;); Collections.sort(list);   "});index.add({'id':4,'href':'/en/posts/javanote_3/','title':"JavaNote_3",'content':"摘要：String; StringBuffer; StringBuilder; 包装类\nString #   字符串属于引用数据类型。 使用双引号括起来的都是String对象。 String对象一旦出生不可变。 垃圾回收器不会释放常量。 凡是用双引号括起来的字符串都是存储在“方法区”的“字符串常量池”中。  创建方法 #  1 2 3 4 5 6  String s = new String(\u0026#34;\u0026#34;); String s = \u0026#34;\u0026#34;; String s = new String(char数组); String s = new String(char数组, 起始下标，长度); String s = new String(byte数组); String s = new String(byte数组, 起始下标, 长度)   采用双引号方法创建的String对象：\n假如采用new的方法创建String对象：\nString局部变量中保存的不是字符串，而是字符串的地址。\n比较字符串 #  1 2 3 4 5 6 7 8 9  public class StringTest { public static void main(String[] args) { String s1 = \u0026#34;hello\u0026#34;; String s2 = \u0026#34;hello\u0026#34;; System.out.println(s1 == s2); // 输出是？？？  // true  } }   原因：\n1 2 3 4 5 6 7 8 9  public class StringTest { public static void main(String[] args) { String x = new String(\u0026#34;xyz\u0026#34;); String y = new String(\u0026#34;xyz\u0026#34;); System.out.println(x == y); // 输出是？？？  // false  } }   原因：会在堆中创建两个不同的对象指向字符串常量池中同一个“xyz”。所以x和y指向的堆中的对象不同，地址也就不同。\n因此，比较String要调用equals方法。\n面试题 #  以下代码创建了几个对象？\n1 2 3 4 5 6  public class StringTest03 { public static void main(String[] args) { String s1 = new String(\u0026#34;hello\u0026#34;); String s2 = new String(\u0026#34;hello\u0026#34;); } }   上述代码一共创建了3个对象：方法区字符串常量池中有一个，堆内存中有两个。\n方法 #  char charAt(int index)\nint compareTo(charSequence s)\nboolean contains(CharSequence s)\nboolean endsWith(String suffix)\nboolean startsWith(String prefix)\nbyte[] getBytes()\nint indexOf(String str): 判断某个字符串在当前字符串中第一次出现的索引\nint lastInexOf(String str)\nboolean isEmpty(): 判断字符串是否为空\nint length()\nString replace(CharSequence target, CharSequence replacement): 将字符串中的target替换为replacement\nString replaceAll(String regex, String replacement) : 替换所有匹配正则表达式regex的子字符串。\nString replaceFirst(String regex, String replacement)\nString[] split(String regex)  :以regex作为分隔符\nString substring(int beginIndex):以参数作为起始下标开始截取子字符串\nString substring(int beginIndex, int endIndex):左闭右开\nchar[] toCharArray() : 将字符串转为char数组\ntoLowerCase() ：转化为小写\ntoUpperCase()\nString trim() : 去除前后空白\nString valueOf(任意类型) ： 将参数转为字符串。String类中的静态方法。直接String.valueOf()。println调用的就是这个方法。这个方法对不同的参数类型有重载。\nStringBuffer #  由于字符串的不可变，字符串的频繁拼接会占用大量方法区内存，造成内存空间的浪费。\n因此，需要采用新的类型：StringBuffer。\n实现与方法 #  底层是byte[]。默认初始容量为16。\n注意：String底层是final byte[]，指向数组的局部变量的指向无法改变，因此进行修改时，老数组无法被释放\n注意：数组的容量确定之后，不能改变。\nappend()：追加。当byte[]数组满了之后，会创建更大的数组，进行arraycopy，并改变指向数组的局部变量的指向，而原byte数组就会被垃圾回收期回收。\n如何优化StringBuffer的性能？\n在创建StringBuffer时给定一个稍大的初始化容量，减少扩容次数。\nStringBuilder #  同样可以进行追加。\nStringBuilder与StringBuffer的区别 #  StringBuffer中的方法都有：synchronized关键字修饰。在多线程环境下运行是安全的。\nStringBuilder中的方法没有：synchronized关键字修饰。他不是线程安全的。\n 包装类型 #  属于引用数据类型。对基本数据类型的拓展。\n基本类型对应的包装类型列举 #     基本数据类型 包装类型     byte java.lang.Byte（父：Number）   short java.lang.Short（父：Number）   int java.lang.Integer（父：Number）   long java.lang.Long（父：Number）   float java.lang.Float（父：Number）   double java.lang.Double（父：Number）   boolean java.lang.Boolean（父：Object）   char java.lang.Character（父：Object）    Number #  抽象类。\n方法（拆箱）：\n1 2 3 4 5 6 7  // Number的方法（拆箱）：将引用数据类型转为基本数据类型 abstract float floatValue(); abstract double doubleValue(); abstract int intValue(); abstract byte byteValue(); abstract short shortValue(); abstract long longValue();   例子：\n1 2 3 4 5 6 7  { // 基本数据类型 --\u0026gt; 引用数据类型 （装箱） \tInteger i = new Integer(123); // 引用数据类型 --\u0026gt; 基本数据类型（拆箱 ） \tfloat f = i.floatValue(); }   Integer #  构造方法\n1 2  Integer(int); Integer(String);   最大最小值\n1 2  Integer.MAX_VALUE Integer.MIN_VALUE   自动拆箱和装箱（JDK1.5之后）\n1 2 3 4 5  //自动装箱 Integer x = 100; //自动拆箱 int y = x;   内存地址（重要的面试题）\n1 2 3 4 5 6 7 8 9 10 11  class TestInteger{ public static void main(String[] args) { Integer x1 = 1000; Integer x2 = 1000; System.out.println(x1 == x2); // false  Integer y1 = 127; Integer y2 = 127; System.out.println(y1 == y2); // true \t} }   原因：Java中为了提高程序的执行效率，在Integer类加载时，会将[-128, 127]之间所有的包装对象提前创建好，放到了方法区的“整数型常量池”当中。因此使用这些数字时不需要new，直接指向常量池中的对应数字。\n重要的方法\n将字符串转为int\n1 2 3 4 5 6 7 8 9 10 11 12  /* 将字符串转为int static int parseInt(String s) */ int retValue = Integer.parseInt(\u0026#34;123\u0026#34;); /* 类似的： Double.parseDouble(String s) Float.parseFloat(String s) */   将int或String转为Integer\n1 2 3 4 5 6  /* static Integer valueOf(int i) static Integer valueOf(String s) */ Integer i1 = Integer.valueOf(100); Integer i2 = Integer.valueOf(\u0026#34;100\u0026#34;);   总结：String，int，Integer互转\n"});index.add({'id':5,'href':'/en/posts/javanote_2/','title':"JavaNote_2",'content':"摘要：Object; 数组;\nObject #  toString() #  默认输出是：类名@地址，建议重写该方法。println引用时，会自动调用该方法。\nequals() #  默认的equals方法采用了双等号'=='进行判断，对于基本类型可以，对于引用类型，比较的只是内存地址，因此针对不同的类需要进行重写。\nString类是引用数据类型。已经重写了toString方法和equals方法。java中的所有字符串字面值都作为String类的实例实现。\n对于引用数据类型，采用equals判断相等。对于基本数据类型，采用==。\n只要写到类，在你的类中都写上toString和equals。\nfinalize() #  执行时机：当一个java对象即将被垃圾回收机制回收前，会自动调用这个方法。类似静态代码块。静态代码块在类加载时执行，且只执行一次。\nhashcode() #  实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。\n 匿名内部类 #  在类的内部又定义了新的类，被称为内部类。包括：静态内部类，实例内部类，局部内部类，匿名内部类。使用内部类编写的代码可读性太差，尽量别用。\n匿名内部类的主要功能是：可以不用显式地对接口进行实现。直接new接口并对方法进行实现即可。缺点：1. 代码乱，可读性差 2. 复用性低\n1 2 3 4 5 6 7 8 9  mm.mySum(new Compute(){ public int sum(int a, int b) { return a + b; } }, 200, 300); interface Compute { int sum(int a, int b); }    数组 #  引用数据类型。父类是Object。\n可以存储基本数据类型或者引用数据类型（存储地址）。\n数组一旦创建，长度不可变。\nlength属性获取数组中元素的个数。\n数组中元素要求类型统一。\n数组中每个元素的地址连续排列。并且将第一个元素的内存地址作为整个数组的地址。\n优点：检索效率高。why？\n 每个元素的内存地址在存储上连续。 每个元素类型相同，占用空间大小相同。 知道第一个元素的地址，每个元素空间大小，通过下标算出偏移量，就能够推算出某个元素的地址。定位效率O(1)  缺点：\n 增删难 不能存储大数据量。因为难以找到一块大的连续空间。  定义与初始化 #  1 2 3 4 5 6 7  // 以下两种定义方式都可以 int[] array1; int array1[ ]; // 初始化 int[] array1 = {100, 2100, 300, 55}; // 静态初始化方法 int[] array2 = new int[5]; // 这里的5表示元素个数，默认值0   直接作为参数：\n1 2 3 4 5 6  /* 方法：printArray(); ========================= */ printArray(new int[ ]{ 1, 2, 3}); // 直接传入静态数组 printArray(new int[3]); // 传入动态数组   定义二维数组：\n1  int[][] a = {{}, {}, {}};   main方法中的参数数组args #  1 2 3 4  public class test { public static void main(String[] args) { } }   这个数组是留给用户的。用户可以在控制台上输入参数，这个参数自动会被转换为String[] args\n如：\njava className param1 param2 param1和param2会自动放进args数组。变成：{\u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;}\n数组的多态 #  父类数组可以存储子类元素。可以直接调用重写的方法。\n假如调用子类的特有方法，则需要进行转型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  public class test { public static void main(String[] args) { Animal[] animals = new Animal[2]; animals[0] = new Cat(); animals[1] = new Bird(); animals[0].move(); animals[1].move(); //要调用miumiu和fly，需要进行类型转化。  for (int i = 0; i \u0026lt; animals.length; ++i) { if (animals[i] instanceof Cat) { Cat c = (Cat)animals[i]; c.miumiu(); } else if (animals[i] instanceof Bird) { Bird b = (Bird)animals[i]; b.fly(); } } } } class Animal { public void move() { System.out.println(\u0026#34;Animal move....\u0026#34;); } } class Cat extends Animal { public void move() { System.out.println(\u0026#34;Cat move...\u0026#34;); } public void miumiu() { System.out.println(\u0026#34;Cat miumiu\u0026#34;); } } class Bird extends Animal { public void move() { System.out.println(\u0026#34;Bird move...\u0026#34;); } public void fly() { System.out.println(\u0026#34;Bird flying\u0026#34;); } }   数组扩容、 数组复制 #  新建一个更大的数组，然后将原数组复制到新数组中。\n可以使用：\n1  System.arraycopy(Object src, int srcPos, Object dest, int destPost, int length); //length 拷贝长度   内存情况 #  存储引用数据类型时：\n案例：数组实现栈 #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class MyStack { private Object[] elements; private int length = 0; public MyStack() { elements = new Object[10]; } public void push(Object element) { if(length \u0026lt; elements.length) { elements[length] = element; length++; } else { System.out.println(\u0026#34;Stack full.....\u0026#34;); } } public void pop() { if (length \u0026gt; 0) { elements[length-1] = null; length--; } else { System.out.println(\u0026#34;Stack is empty....\u0026#34;); } } public void showStack() { for(int i = 0; i \u0026lt; length; ++i) { System.out.println(elements[i]); System.out.println(\u0026#34;==========\u0026#34;); } } public static void main(String[] args) { MyStack st = new MyStack(); String s = new String(\u0026#34;Hello\u0026#34;); st.push(s); st.showStack(); st.pop(); st.pop(); } }   数组算法 #  java.util.Arrays是一个工具类，里面有sort()方法，可以排序。\n"});index.add({'id':6,'href':'/en/posts/javanote_1/','title':"JavaNote_1",'content':"摘要：类和对象; 方法; 变量; 常量; 内存与机器; 修饰符;\n类和对象 #  一些规则 #  在Java中任何有效的代码必须写到“类”中，最外层必须是一个类的定义。类体中应该是方法或者变量，不能是直接的Java语句。\n一个Java源文件中可以定义多个class.\npublic的类可以没有，如果有的话，每个Java文件中只能有一个，并且类名要和文件名一致.\n封装的作用：保证内部结构安全；暴露简单，屏蔽复杂\npackage和import机制 #  为什么要使用package？\n包机制可以方便程序管理，将不同功能的类分别存放在不同的包下。\npackage怎么用？\npackage + 包名。如package com.bjpowernode.javase\n命名规范？\n公司域名倒序 + 项目名 + 模块名 + 功能名\n如何编译和运行？\n类名不再是：HelloWorld，而是：com.bjpowernode.javase.HelloWorld\n路径在：com/bjpowernode/javase/HelloWorld\n编译：（生成对应文件夹）\n构造方法 #  类如果不提供构造方法 会自动给予无参构造方法。假如自己写了任何构造方法（有参或者无参），编译器将不会自动添加无参构造方法。因此，要写构造方法就要把有参和无参都写了.\n构造方法格式: public className(parameters list)\n构造方法支持重载\n抽象类 #  抽象类也属于引用数据类型。\n定义方法：\n1 2 3  [修饰符列表] abstract class Name { something; }   抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被继承的。\n抽象类有构造方法，且构造方法只能给子类使用。类的默认构造方法里会有super()，调用父类的无参构造方法。\n作用：\n配合多态，可以实现面向抽象编程，降低程序的耦合度，提高程序的扩展力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /* * Copyright: Copyright (c) 2020. Baixi Bennett. All rights reserved. * Created on: 2020/4/23 * Author: Baixi Bennett * Github: huangbxaaa * Weibo: GRABShbx * Gmail: huangbx666@gmail.com */ public class AbstractTest { public static void main(String[] args) { Animal a = new Cat(); Animal b = new Dog(); a.move(); System.out.println(\u0026#34;--------------\u0026#34;); b.move(); /* 编译时，move方法指向的是Animal中的move方法。 运行时，由于地址指向的是类Cat/Dog所在的堆内存，因此调用的是Cat/Dog的move方法 */ } } abstract class Animal { public abstract void move(); } class Cat extends Animal { public void move() { System.out.println(\u0026#34;Cat moving\u0026#34;); } } class Dog extends Animal { public void move() { System.out.println(\u0026#34;Dog moving\u0026#34;); } }   接口类 #  1 2 3 4 5 6 7 8  [修饰符列表] interface 接口名 { } 例： interface MyMath { double PI = 3.14; int sum(int a, int b); }    接口是一种引用数据类型 接口是完全抽象的 接口支持多继承接口中只包括两部分：  常量（public static final可以省略） 抽象方法（public abstract修饰符可以省略）   接口中所有的元素都是public 抽象方法不能带有方法体 有了接口就有了可插拔，扩展力很强  类与类之间叫继承；类与接口之间叫做实现（采用implements关键字）。\n实现接口时，必须将接口中所有的方法全部实现。\n进行继承或者实现时，子类的访问权限不能比父类更低。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  interface MyMath{ double PI = 3.14; //编译器会自动加上 public static final  int sum(int a, int b); int sub(int a, int b); //编译器会自动加上 public abstract } class MyMathImp implements MyMath { /* 这个方法报错：理由：正在尝试分配更低的访问权限，应该加上public int sum(int a, int b) { return a + b } */ public int sum(int a, int b) {} public int sub(int a, int b) {} }   同样可以配合多态，实现抽象编程。\n接口可以多继承。弥补了类与类之间只能单继承的缺陷。但是采用多态时，只能访问本类方法。\n转型的时候最好用instance of判断一下。\n继承和实现都存在时，extends 关键字在前，implements关键字在后。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  public class AnimalTest { public static void main(String[] args) { Flyable f1 = new NewCat(12); f1.fly(); Flyable f2 = new NewDog(13); f2.fly(); } } class NewAnimal { int age; public NewAnimal(int age) { this.age = age; } } interface Flyable { void fly(); } class NewCat extends NewAnimal implements Flyable { public NewCat(int age) { super(age); } @Override public void fly() { System.out.println(\u0026#34;cat is flying\u0026#34;); } } class NewDog extends NewAnimal implements Flyable { public NewDog(int age) { super(age); } @Override public void fly() { System.out.println(\u0026#34;dog is flying\u0026#34;); } }   接口相当于可插拔的。\n接口如何实现解耦：分离开调用者和实现者。\n注意：Java里面，不区分大小写。类名，接口名大小写不敏感。\n抽象类与接口的区别：\n抽象类是半抽象的。接口是完全抽象的。\n抽象类中有构造方法。接口中没有构造方法。\n接口和接口之间支持多继承。类和类之间只能单继承。\n一个类可以同时实现多个接口。一个抽象类只能继承一个类。（单继承）\n接口中只允许出现常量和抽象方法。\n以后接口使用的比抽象类多，一般抽象类使用的还是少。接口一般都是对“行为”的抽象。\n类与类的关系 #     is a 继承     has a 关联。以“属性”形式存在   use a 实现。以“接口”形式存在    访问控制权限 #     修饰符 本类 同包 子类 任意位置     public √ √ √ √   protected √ √ √ ×   默认 √ √ × ×   private √ × × ×    方法 #  重载：方法名相同，参数不同。完成功能相似的方法。只有返回值不同不叫重载，编译器会判定为方法重复。\n参数传递，在栈中的基本变量进行复制，在堆中的引用变量进行地址传递.\nget和set方法都不带有static，都是实例方法。因为操作的都是对象的属性。\n抽象方法 #  没有实现的方法，没有方法体的方法。\n特点：\n 没有方法体，以分号结尾 修饰符列表中有abstract关键字  抽象类中可以没有抽象方法。抽象方法必须放在抽象类中。\n因此，子类（非抽象类）继承父类（抽象类），就必须对抽象方法进行实现/覆盖/重写。否则子类会继承父类的抽象方法而出错。\n判断题：没有方法体的方法都是抽象方法？（错误，Object类源码中就有很多方法没有方法体，底层调用的是C++动态链接库）\n变量 #  引用数据类型：所有的类，String；\n基本数据类型：byte，short，int，long，float，double，char，boolean\n类中的实例变量（非静态）必须通过实例化后才能访问，否则不存在。\n对象的实例变量（成员变量）会附初始值0；方法中的局部变量则不会。\n私有属性变量，在static函数中不能访问。\n常量 #  static final修饰的称为常量，常量名全部大写，每个单词采用下划线链接。\n常量和静态变量都存储在方法区，并且都在类加载时初始化。\n内存与机器 #  编译器会自动寻找依赖文件进行编译。\n凡是通过new创建的对象，都存在堆中。地址付给局部变量。这种保存了地址的变量叫做引用。当一个对象没有引用指向，会自动被当做垃圾回收走\n修饰符 #  final #  final表示不可变的。final修饰的方法不能被覆盖，被重写，被继承。\nfinal修饰的变量只能赋一次值，一旦赋值不可改。\nfinal修饰的实例变量，系统不会赋给它默认值，要求程序员手动赋值，可以直接定义时赋值或者在构造方法中赋值。（不背锅）。假如没有final则会赋默认值0。\nfinal实例变量定义与初始化方法：\n1 2 3 4 5 6 7 8  class User { final double height = 1.9; // 或者  final double weight; public User() { this.weight = 80; } }   final修饰的实例变量永远不会改变，并且不同的对象持有的该属性都是相同的。为了节省堆空间，将其改为静态变量，存储在方法区会更好：\n1 2 3  class User { static final HEIGHT = 1.9; }   "});index.add({'id':7,'href':'/en/about/','title':"About",'content':""});index.add({'id':8,'href':'/en/posts/hello-world/','title':"配置个人网页",'content':"建立个人博客 #  这是我的第一篇文章，记录一下使用hugo开设个人博客过程中参考的资料和遇到的问题。\n流程 #  官方教程：这个教程将博客内容与hugo渲染内容全部部署到github上，分别放置于两个不同的仓库，通过submodule来实现关联，十分的有效。而且教程还提供了自动生成静态文件并上传github的shell脚本文件。\n中文教程 ：这个大概看了一下，没仔细阅读。\n主题meme：这是我挑选的喜欢的主题。\n遇到的问题 #  css文件被加密，Chrome无法读取 #  我在原主题下开了个issue，不过自己后面解决了就关了\n本地渲染的blog在gitpage不显示 #  stackoverflow：查阅资料发现，要想执行hugo之后能够看到自己在hugo server -D时显示正常的blog，必须把blog头部的draft:true 改为draft:false\n在官方文档中：末尾也有提到，不过没有仔细看，忽略了\n最后 #  坚持写博客呀！！！\nfaith，love，confidence！！！\n"});index.add({'id':9,'href':'/en/contact/','title':"Contact",'content':"This is contact page.\n"});})();